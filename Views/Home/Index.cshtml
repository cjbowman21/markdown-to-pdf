@{
    ViewData["Title"] = "Home Page";
}

@model string

<ul class="nav nav-tabs d-md-none mb-3" id="mobileTabs">
    <li class="nav-item">
        <button class="nav-link active" id="editor-tab" type="button">Editor</button>
    </li>
    <li class="nav-item">
        <button class="nav-link" id="preview-tab" type="button">Preview</button>
    </li>
</ul>

<div class="row">
    <div class="col-md-6 d-md-block" id="editorPane">
        <form method="post" asp-action="GeneratePdf">
            <textarea id="markdownInput" name="markdown" class="form-control no-wrap" rows="25" wrap="off">@Model</textarea>
            <button type="submit" class="btn btn-primary mt-3">Generate PDF</button>
        </form>
    </div>
    <div class="col-md-6 d-none d-md-block" id="previewPane">
        <div id="preview" class="border p-3 h-100 overflow-auto"></div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        const input = document.getElementById('markdownInput');
        const preview = document.getElementById('preview');
        const editorPane = document.getElementById('editorPane');
        const previewPane = document.getElementById('previewPane');
        const editorTab = document.getElementById('editor-tab');
        const previewTab = document.getElementById('preview-tab');
        let lines = [];
        let syncingFromInput = false;
        let syncingFromPreview = false;

        function updatePreview() {
            const cleaned = input.value.replace(/<!--\s*\{\{.*?\}\}\s*-->/g, '');
            lines = cleaned.split('\n');
            preview.innerHTML = marked.parse(cleaned);
        }

        function showEditor() {
            editorPane.classList.remove('d-none');
            previewPane.classList.add('d-none');
            editorTab.classList.add('active');
            previewTab.classList.remove('active');
        }

        function showPreview() {
            previewPane.classList.remove('d-none');
            editorPane.classList.add('d-none');
            previewTab.classList.add('active');
            editorTab.classList.remove('active');
        }

        function syncScroll(source, target) {
            const percentage = source.scrollTop / (source.scrollHeight - source.clientHeight);
            target.scrollTop = percentage * (target.scrollHeight - target.clientHeight);
        }

        editorTab.addEventListener('click', showEditor);
        previewTab.addEventListener('click', showPreview);

        input.addEventListener('input', updatePreview);

        input.addEventListener('scroll', () => {
            if (syncingFromPreview) {
                syncingFromPreview = false;
                return;
            }
            syncingFromInput = true;
            syncScroll(input, preview);
        });

        preview.addEventListener('scroll', () => {
            if (syncingFromInput) {
                syncingFromInput = false;
                return;
            }
            syncingFromPreview = true;
            syncScroll(preview, input);
        });

        function clearHighlight() {
            preview.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        }

        function highlightPreviewLine(line) {
            clearHighlight();
            const text = lines[line];
            if (!text) return;
            const plain = text
                .replace(/<!--\s*\{\{.*?\}\}\s*-->/g, '')
                .replace(/\[(.*?)\]\(.*?\)/g, '$1')
                .replace(/[*_`#>\-\[\]]/g, '')
                .trim();
            if (!plain) return;
            const walker = document.createTreeWalker(preview, NodeFilter.SHOW_TEXT, null);
            while (walker.nextNode()) {
                if (walker.currentNode.nodeValue.trim() === plain) {
                    walker.currentNode.parentElement.classList.add('highlight');
                    break;
                }
            }
        }

        function hoveredLine(e) {
            const rect = input.getBoundingClientRect();
            const lineHeight = parseInt(window.getComputedStyle(input).lineHeight);
            return Math.floor((e.clientY - rect.top + input.scrollTop) / lineHeight);
        }

        input.addEventListener('mousemove', (e) => {
            highlightPreviewLine(hoveredLine(e));
        });

        input.addEventListener('mouseleave', clearHighlight);

        updatePreview();
    </script>
}
