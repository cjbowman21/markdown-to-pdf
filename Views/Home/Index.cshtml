@{
    ViewData["Title"] = "Home Page";
}

@model string

<ul class="nav nav-tabs d-md-none mb-3" id="mobileTabs">
    <li class="nav-item">
        <button class="nav-link active" id="editor-tab" type="button">Editor</button>
    </li>
    <li class="nav-item">
        <button class="nav-link" id="preview-tab" type="button">Preview</button>
    </li>
</ul>

<div class="row">
    <div class="col-md-6 d-md-block" id="editorPane">
        <form method="post" asp-action="GeneratePdf">
            <textarea id="markdownInput" name="markdown" class="form-control no-wrap" wrap="off">@Model</textarea>
            <button type="submit" class="btn btn-primary mt-3">Generate PDF</button>
        </form>
    </div>
    <div class="col-md-6 d-none d-md-block" id="previewPane">
        <div id="preview" class="border p-3 h-100"></div>
    </div>
</div>

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        const input = document.getElementById('markdownInput');
        const preview = document.getElementById('preview');
        const previewScroll = preview;
        const editorPane = document.getElementById('editorPane');
        const previewPane = document.getElementById('previewPane');
        const editorTab = document.getElementById('editor-tab');
        const previewTab = document.getElementById('preview-tab');
        let lines = [];
        let elementMap = new Map();
        let syncingFromInput = false;
        let syncingFromPreview = false;

        function updatePreview() {
            const cleaned = input.value.replace(/<!--\s*\{\{.*?\}\}\s*-->/g, '');
            lines = cleaned.split('\n');
            preview.innerHTML = marked.parse(cleaned);
            elementMap.clear();
            const elements = Array.from(
                preview.querySelectorAll('li, p, pre, blockquote, h1, h2, h3, h4, h5, h6')
            ).filter(el => el.tagName === 'LI' || !el.closest('li'));
            let index = 0;
            for (let i = 0; i < lines.length && index < elements.length; i++) {
                const plain = lines[i]
                    .replace(/<!--\s*\{\{.*?\}\}\s*-->/g, '')
                    .replace(/\[(.*?)\]\(.*?\)/g, '$1')
                    .replace(/[*_`#>\[\]-]/g, '')
                    .replace(/\s+/g, ' ')
                    .trim();
                if (plain) {
                    elementMap.set(i, elements[index++]);
                }
            }
        }

        function showEditor() {
            editorPane.classList.remove('d-none');
            previewPane.classList.add('d-none');
            editorTab.classList.add('active');
            previewTab.classList.remove('active');
        }

        function showPreview() {
            previewPane.classList.remove('d-none');
            editorPane.classList.add('d-none');
            previewTab.classList.add('active');
            editorTab.classList.remove('active');
        }

        function syncScroll(source, target) {
            const percentage = source.scrollTop / (source.scrollHeight - source.clientHeight);
            target.scrollTop = percentage * (target.scrollHeight - target.clientHeight);
        }

        editorTab.addEventListener('click', showEditor);
        previewTab.addEventListener('click', showPreview);

        input.addEventListener('input', updatePreview);

        input.addEventListener('scroll', () => {
            if (syncingFromPreview) {
                syncingFromPreview = false;
                return;
            }
            syncingFromInput = true;
            syncScroll(input, previewScroll);
        });

        previewScroll.addEventListener('scroll', () => {
            if (syncingFromInput) {
                syncingFromInput = false;
                return;
            }
            syncingFromPreview = true;
            syncScroll(previewScroll, input);
        });

        function clearHighlight() {
            preview.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
        }

        function highlightPreviewLine(line) {
            clearHighlight();
            const target = elementMap.get(line);
            if (target) {
                target.classList.add('highlight');
            }
        }

        function hoveredLine(e) {
            const rect = input.getBoundingClientRect();
            const lineHeight = parseInt(window.getComputedStyle(input).lineHeight);
            return Math.floor((e.clientY - rect.top + input.scrollTop) / lineHeight);
        }

        input.addEventListener('mousemove', (e) => {
            highlightPreviewLine(hoveredLine(e));
        });

        input.addEventListener('mouseleave', clearHighlight);

        updatePreview();
    </script>
}
